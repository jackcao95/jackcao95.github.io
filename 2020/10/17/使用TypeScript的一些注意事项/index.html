<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="John Doe"><meta name="renderer" content="webkit"><meta name="copyright" content="John Doe"><meta name="keywords" content="Hexo"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>使用TypeScript的一些注意事项 · Mr.Jack's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/cat.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">jackcao95</div><div class="profile-signature">for me</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Mr.Jack's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">使用TypeScript的一些注意事项</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2020-10-17</span></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">3k</span> | Reading time: <span class="post-count">12</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h2 id="易混乱的类型"><a href="#易混乱的类型" class="headerlink" title="易混乱的类型"></a>易混乱的类型</h2><p>如果问“ts 的变量有多少种类型”，你能否回答全面？ts 比 js 类型多一些。</p>
<h3 id="never-vs-void"><a href="#never-vs-void" class="headerlink" title="never vs void"></a><code>never</code> vs <code>void</code></h3><p>只需要记住一个特点：返回 <code>never</code> 的函数，都必须存在无法到达的终点，如死循环、抛出异常。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="comment">/*...*/</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="any-vs-unknown"><a href="#any-vs-unknown" class="headerlink" title="any vs unknown"></a><code>any</code> vs <code>unknown</code></h3><ul>
<li><code>any</code> 任何类型，会忽略语法检查</li>
<li><code>unknown</code> 不可预知的类型，不会忽略语法检查（这就是最大区别）</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">any</span>.substr(<span class="number">1</span>); <span class="comment">// OK - any 会忽略所有类型检查</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: unknown = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">foo.substr(<span class="number">1</span>); <span class="comment">// Error: 语法检查不通过报错</span></span><br><span class="line"><span class="comment">// (foo as string).substr(1) // OK</span></span><br><span class="line"><span class="comment">// if (typeof foo === &#x27;string&#x27;) &#123; foo.substr(1) &#125; // OK</span></span><br></pre></td></tr></table></figure>

<h2 id="一些“欺骗”编译器语法检查的行为"><a href="#一些“欺骗”编译器语法检查的行为" class="headerlink" title="一些“欺骗”编译器语法检查的行为"></a>一些“欺骗”编译器语法检查的行为</h2><blockquote>
<p>就如同你告诉编译器：“按我写的来，不要管太多，出了事儿我负责！”</p>
</blockquote>
<p>编译器不给你添麻烦了，不进行语法检查了，但你一定要考虑好后果。所以，以下内容请慎用，不要无脑使用。</p>
<h3 id="ts-ignore"><a href="#ts-ignore" class="headerlink" title="@ts-ignore"></a><code>@ts-ignore</code></h3><p>增加 <code>@ts-ignore</code> 的注释，会忽略下一行的语法检查。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1: <span class="built_in">number</span> = <span class="number">100</span></span><br><span class="line">num1.substr() <span class="comment">// Error 语法检查错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num2: <span class="built_in">number</span> = <span class="number">200</span></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line">num2.substr() <span class="comment">// Ok 语法检查通过</span></span><br></pre></td></tr></table></figure>

<h3 id="any"><a href="#any" class="headerlink" title="any"></a><code>any</code></h3><p>如果 ts 是西游记，<code>any</code> 就是孙悟空，自由、无约束。了解西游记大部分是从孙悟空开始，了解 ts 可能也是从 <code>any</code> 开始用。</p>
<p>但西游记最后，孙悟空变成了佛。你的 <code>any</code> 也应该变成 interface 或者 type 。</p>
<h3 id="类型断言-as"><a href="#类型断言-as" class="headerlink" title="类型断言 as"></a>类型断言 <code>as</code></h3><p>文章一开始说过，ts 只管编译时，不管运行时。<code>as</code> 就是典型的例子，你用 <code>as</code> 告诉编译器类型，编译器就听你的。但运行时，后果自负。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = (a <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br><span class="line">    <span class="built_in">console</span>.log(length)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// Ok</span></span><br><span class="line"><span class="comment">// fn(null) // Error js 运行报错</span></span><br></pre></td></tr></table></figure>

<h3 id="非空断言操作符"><a href="#非空断言操作符" class="headerlink" title="非空断言操作符 !"></a>非空断言操作符 <code>!</code></h3><p><code>!</code> 用于排除 <code>null</code> <code>undefined</code> ，即告诉编译器：xx 变量肯定不是 <code>null</code> 或 <code>undefined</code> ，你放心吧～</p>
<p>同理，运行时有可能出错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a: <span class="built_in">string</span> | <span class="literal">null</span> | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    s = a <span class="comment">// Error 语法检查失败</span></span><br><span class="line">    s = a! <span class="comment">// OK —— 【注意】如果 a 真的是 null 或者 undefined ，那么 s 也会是 null 或者 undefined ，可能会带来 bug ！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn(null)</span></span><br><span class="line"><span class="comment">// 例子 2</span></span><br><span class="line"><span class="keyword">type</span> NumGenerator = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">numGenerator: NumGenerator | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> num1 = numGenerator(); <span class="comment">// Error 语法检查失败</span></span><br><span class="line">  <span class="keyword">const</span> num2 = numGenerator!(); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myFunc(undefined) // 【注意】，如果真的传入 undefined ，也会去执行，当然会执行报错！！！</span></span><br><span class="line"><span class="comment">// 例子 3</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Error - Variable &#x27;n&#x27; is used before being assigned.</span></span><br><span class="line"><span class="keyword">let</span> b!: <span class="built_in">number</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// OK - `!` 表示，你会给 b 一个赋值，不用编译器关心</span></span><br></pre></td></tr></table></figure>

<h3 id="可选链"><a href="#可选链" class="headerlink" title="可选链 ?."></a>可选链 <code>?.</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?.&#96; 遇到 &#96;null&#96; 或 &#96;undefined&#96; 就可以立即停止某些表达式的运行，并返回 &#96;undefined</span><br></pre></td></tr></table></figure>

<p>【注意】这里只针对 <code>null</code> 和 <code>undefined</code> ，对于 <code>0</code> <code>false</code> <code>&#39;&#39;</code> 等 falsely 变量是不起作用的。这一点和 <code>&amp;&amp;</code> 不一样。</p>
<p>这个运算符，看似是获取一个属性，其实它是有条件判断的。即，它就是一个 <code>? :</code> 三元表达式的语法糖。既然它有判断逻辑，那你考虑不到位，就有可能出错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子 1 - 获取对象属性</span></span><br><span class="line"><span class="keyword">interface</span> IFoo &#123; a: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj: IFoo | <span class="literal">null</span> | <span class="literal">undefined</span></span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = obj?.a <span class="comment">// ?. 可选链运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一，如果 a 是 IFoo 类型，则打印 100</span></span><br><span class="line">    <span class="comment">// 第二，如果 a 是 null 或者 undefined ，则打印 undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a <span class="comment">// 100 或者 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn(&#123; <span class="attr">a</span>: <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">// fn(null)</span></span><br><span class="line"><span class="comment">// fn(undefined)</span></span><br><span class="line"><span class="comment">// 例子 2 - 获取数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryGetArrayElement</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr?: T[], index: <span class="built_in">number</span> = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr?.[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译产出：</span></span><br><span class="line"><span class="comment">// &quot;use strict&quot;;</span></span><br><span class="line"><span class="comment">// function tryGetArrayElement(arr, index = 0) &#123;</span></span><br><span class="line"><span class="comment">//     return arr === null || arr === void 0 ? void 0 : arr[index];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 例子 3 - 用于函数调用</span></span><br><span class="line"><span class="keyword">type</span> NumGenerator = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">numGenerator: NumGenerator | <span class="literal">undefined</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> num = numGenerator?.();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;num&#x27;</span>, num) <span class="comment">// 如果不是函数，则不调用，也不会报错，返回 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn(null)</span></span><br><span class="line"><span class="comment">// fn(undefined)</span></span><br></pre></td></tr></table></figure>

<p>【吐槽】对于这种语法糖，我还是比较反感的，我觉得自己写几行逻辑判断会更好。它虽然简洁，但是它会带来阅读理解上的负担，代码简洁不一定就可读性好 —— 当然了，如果大家都这么用，用久了，大家都熟悉了，可能也就没有这个障碍了。</p>
<h2 id="type-和-interface"><a href="#type-和-interface" class="headerlink" title="type 和 interface"></a>type 和 interface</h2><p>关于两者的区别，大家可以看看<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903749501059085">这篇文章</a> ，本文主要说一下我的理解。</p>
<p>先说结论：我目前还是处于一种懵逼状态。我感觉 type 和 insterface 有太多的灰色地带，这就导致我们日常使用时，大部分情况下用谁都可以。我搞不懂 ts 为何要这样设计。</p>
<p>按照我前些年对 java 和 C# 的理解：（我不知道近几年 java C# 有没有相关的语法变化）</p>
<ul>
<li>如果自定义一个静态的类型，仅有一些属性，没有方法，就用 <code>type</code></li>
<li>如果定义一种行为（行为肯定是需要方法的，仅属性是不够的），需要 class 实现，就用 <code>interface</code></li>
</ul>
<p>但是查到的资料，以及查阅 ts 的类库 lib.dom.d.ts 和 lib.es2015.d.ts 源码，也都是用 interface 。我曾经一度很困惑，见的多了，就慢慢习惯成自然了，但问题并没有解决。</p>
<p>问题没有解决，但事情还是要继续做的，代码也是要继续写的，所以我就一直跟随大众，尽量用 interface 。</p>
<h2 id="private-和"><a href="#private-和" class="headerlink" title="private 和 #"></a><code>private</code> 和 <code>#</code></h2><p>两者都表示私有属性。背景不同：</p>
<ul>
<li><code>private</code> 是 ts 中一开始就有的语法，而且目前只有 ts 有，ES 规范没有。</li>
<li><code>#</code> 是 ES 目前的提案语法，然后被 ts 3.8 支持了。即，ts 和 ES 都支持 <code>#</code> 。</li>
</ul>
<p>如果仅对于 ts 来说，用哪个都一样。</p>
<p>但本文一开始提到过：ts 只关注编译时，不关注运行时。所以，还得看看两者的编译结果。</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a><code>private</code></h3><p><code>private</code> 编译之后，就失去了私有的特点。即，如果你执行 <code>(new Person()).name</code> ，虽然语法检查不通过，但运行时是可以成功的。</p>
<p>即，<code>private</code> 仅仅是 ts 的语法，编译成 js 之后，就失效了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译结果如下</span></span><br><span class="line"><span class="comment">&quot;use strict&quot;;</span></span><br><span class="line"><span class="comment">class Person &#123;</span></span><br><span class="line"><span class="comment">    constructor() &#123;</span></span><br><span class="line"><span class="comment">        this.name = &#x27;zhangsan&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title="#"></a><code>#</code></h3><p><code>#</code> 编译之后，依然具有私有特点，而且用 <code>(new Person()).name</code> ，在运行时也是无法实现的。</p>
<p>即，<code>#</code> 是 ts 语法，但同时也是 ES 的提案语法，编译之后也不能失效。</p>
<p>但是，编译结果中，<strong>“私有”是通过 <code>WeekMap</code> 来实现的，所以要确保你的运行时环境支持 ES6</strong> 。<code>WeekMap</code> 没有完美的 Polyfill 方案，强行 Polyfill 可能会发生内存泄漏。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    #name: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.#name = <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译结果如下</span></span><br><span class="line"><span class="comment">&quot;use strict&quot;;</span></span><br><span class="line"><span class="comment">var __classPrivateFieldSet = (this &amp;&amp; this.__classPrivateFieldSet) || function (receiver, privateMap, value) &#123;</span></span><br><span class="line"><span class="comment">    if (!privateMap.has(receiver)) &#123;</span></span><br><span class="line"><span class="comment">        throw new TypeError(&quot;attempted to set private field on non-instance&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    privateMap.set(receiver, value);</span></span><br><span class="line"><span class="comment">    return value;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">var _name;</span></span><br><span class="line"><span class="comment">class Person &#123;</span></span><br><span class="line"><span class="comment">    constructor() &#123;</span></span><br><span class="line"><span class="comment">        _name.set(this, void 0);</span></span><br><span class="line"><span class="comment">        __classPrivateFieldSet(this, _name, &#x27;zhangsan&#x27;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">_name = new WeakMap();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="java-中的函数重载"><a href="#java-中的函数重载" class="headerlink" title="java 中的函数重载"></a>java 中的函数重载</h3><p>java 中的函数重载是非常好用，而且非常好理解的，傻瓜式的，一看就懂。</p>
<p>如下代码，定义了四个名为 <code>test</code> 的函数，参数不同。那就直接写四个函数即可，调用时也直接调用，java 会自动匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest3&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest4&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Overloading o = <span class="keyword">new</span> Overloading();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o.test(<span class="number">1</span>,<span class="string">&quot;test3&quot;</span>));</span><br><span class="line">        System.out.println(o.test(<span class="string">&quot;test4&quot;</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ts-中的函数重载"><a href="#ts-中的函数重载" class="headerlink" title="ts 中的函数重载"></a>ts 中的函数重载</h3><p>ts 的函数重载，先把各个情况的函数头写出来，然后再写一个统一的、兼容上述所有情况的函数头。最后，函数体自行处理参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一，各个情况的函数头写出来</span></span><br><span class="line">    test(): <span class="built_in">void</span></span><br><span class="line">    test(a: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">    test(a: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">    <span class="comment">// 第二，统一的、兼容上述所有情况的函数头（有一个不兼容，就报错）</span></span><br><span class="line">    test(a?: <span class="built_in">string</span> | <span class="built_in">number</span>, b?: <span class="built_in">string</span> | <span class="built_in">number</span>): <span class="built_in">void</span> | <span class="built_in">string</span> | <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="comment">// 第三，函数体自行处理参数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;string params&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;number params&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;no params&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这和 java 的语法比起来，简直就是复杂 + 丑陋，完全违背设计原则</strong>。</p>
<p>但是，为何要这样呢？最终还是因为 ts 只关注编译时，管不了运行时 —— 这是原罪。</p>
<p>试想，如果 ts 也设计像 java 一样的重载写法，那编译出来的 js 代码就会乱套的。因为 js 是弱类型的。</p>
<h3 id="注意函数定义的顺序"><a href="#注意函数定义的顺序" class="headerlink" title="注意函数定义的顺序"></a>注意函数定义的顺序</h3><p>参数越精准的，放在前面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误：any 类型不精准，应该放在最后 */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLElement</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: HTMLDivElement</span>): <span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myElem: HTMLDivElement;</span><br><span class="line"><span class="keyword">var</span> x = fn(myElem); <span class="comment">// x: any, wat?</span></span><br></pre></td></tr></table></figure>

<p>不要为仅在末尾参数不同时写不同的重载，应该尽可能使用可选参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误 */</span></span><br><span class="line"><span class="keyword">interface</span> Example1 &#123;</span><br><span class="line">    diff(one: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">    diff(one: <span class="built_in">string</span>, <span class="attr">two</span>: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">    diff(one: <span class="built_in">string</span>, <span class="attr">two</span>: <span class="built_in">string</span>, <span class="attr">three</span>: <span class="built_in">boolean</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK */</span></span><br><span class="line"><span class="keyword">interface</span> Example2 &#123;</span><br><span class="line">    diff(one: <span class="built_in">string</span>, two?: <span class="built_in">string</span>, three?: <span class="built_in">boolean</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DOM-相关的类型"><a href="#DOM-相关的类型" class="headerlink" title="DOM 相关的类型"></a>DOM 相关的类型</h2><p>Vue 和 React 框架的普及，让大部分业务开发者不用直接操作 DOM ，变成了框架工程师。但 Web 是基于 DOM 的，可以不用，但千万不要忘记。</p>
<p>js 写 DOM 操作非常简单，不用关心类型，直接访问属性和方法即可。但用 ts 之后，就得关心 DOM 操作的相关类型。</p>
<p>不光我们使用 ts ，微软在设计 ts 时，也需要定义 DOM 操作相关的类型，放在 ts 的类库中，这样 ts 才能被 web 场景所使用。这些都定义在 <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts">lib.dom.d.ts</a> 中。补：还有 ES 语法的内置类库，也在同目录下。</p>
<p>PS：一门成熟可用的编程语言，最基本的要包括：语法 + 类库 + 编译器 + 运行时（或者编译器和运行时统一为解释器）。然后再说框架，工具，包管理器等这些外围配置。</p>
<h3 id="Node-Element-等类型"><a href="#Node-Element-等类型" class="headerlink" title="Node Element 等类型"></a>Node Element 等类型</h3><p>这些都是现成的，W3C 早就定义好了的，我们直接回顾一下就可以。我觉得一张图就可以很好的表达，详细的可以参考各自的 MDN 文档。</p>
<p><img src="http://img4.sycdn.imooc.com/6031b59f00017f9408000325.jpg" alt="img"></p>
<h3 id="事件参数类型"><a href="#事件参数类型" class="headerlink" title="事件参数类型"></a>事件参数类型</h3><p>在使用 ts 之前，我并没有特别关注事件参数类型（或者之前看过，后来不用，慢慢忘了），反正直接获取属性，拿来用就可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// e1 的构造函数是什么？</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="params">e2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// e2 的构造函数是什么？</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>于是我查了一下 MDN 的文档，其实也很好理解，就是不同的事件，参数类型是不一样的，当然属性、方法也就不一样。下面列出我们常见的，所有的类型参考 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event">MDN 这个文档</a>。</p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">参数类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">click dbclick mouseup mousedown mousemove mouseenter mouseleave</td>
<td align="left">MouseEvent</td>
</tr>
<tr>
<td align="left">keyup keyrpess keydown</td>
<td align="left">KeyboardEvent</td>
</tr>
<tr>
<td align="left">compositionstart compositionupdate compositionend（输入法）</td>
<td align="left">CompositionEvent</td>
</tr>
<tr>
<td align="left">focus blur focusin focusout</td>
<td align="left">FocusEvent</td>
</tr>
<tr>
<td align="left">drag drop</td>
<td align="left">DragEvent</td>
</tr>
<tr>
<td align="left">paste cut copy</td>
<td align="left">ClipboardEvent</td>
</tr>
</tbody></table>
<p>他们的继承关系如下图。其中 <code>UIEvent</code> 表示的是用户在 UI 触发的一些事件。因为事件不仅仅是用户触发的，还有 API 脚本触发的，所以要单独拿出一个 <code>UIEvent</code> ，作为区分。</p>
<p><img src="http://img1.sycdn.imooc.com/6031b5a00001c3ec16020824.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我感觉重点的就是那句话：<strong>ts 是一门静态类型语言，但它要编译成为 js 这个弱类型语言来执行，所以它管得了编译时，却管不了运行时</strong>。这是很多问题的根本。</p>
</article><!-- lincense--><div class="post-paginator"><a class="prevSlogan" href="/2020/11/03/%E5%80%9F%E5%8A%A9axios%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0Vue-js%E4%B8%AD%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%A3%80%E9%AA%8C%E7%9A%84%E6%80%9D%E8%B7%AF/" title="借助axios的拦截器实现Vue.js中登录状态检验的思路"><span>< PreviousPost</span><br><span class="prevTitle">借助axios的拦截器实现Vue.js中登录状态检验的思路</span></a><a class="nextSlogan" href="/2020/10/15/Vue%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E9%80%9A%E8%BF%87%E6%87%92%E5%8A%A0%E8%BD%BD%E6%8F%90%E5%8D%87%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6/" title="Vue项目性能优化实践-通过懒加载提升页面响应速度"><span>NextPost ></span><br><span class="nextTitle">Vue项目性能优化实践-通过懒加载提升页面响应速度</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%93%E6%B7%B7%E4%B9%B1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">易混乱的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#never-vs-void"><span class="toc-number">1.1.</span> <span class="toc-text">never vs void</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any-vs-unknown"><span class="toc-number">1.2.</span> <span class="toc-text">any vs unknown</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E2%80%9C%E6%AC%BA%E9%AA%97%E2%80%9D%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.</span> <span class="toc-text">一些“欺骗”编译器语法检查的行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ts-ignore"><span class="toc-number">2.1.</span> <span class="toc-text">@ts-ignore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-number">2.2.</span> <span class="toc-text">any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-as"><span class="toc-number">2.3.</span> <span class="toc-text">类型断言 as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">非空断言操作符 !</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE"><span class="toc-number">2.5.</span> <span class="toc-text">可选链 ?.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-%E5%92%8C-interface"><span class="toc-number">3.</span> <span class="toc-text">type 和 interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#private-%E5%92%8C"><span class="toc-number">4.</span> <span class="toc-text">private 和 #</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#private"><span class="toc-number">4.1.</span> <span class="toc-text">private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.</span> <span class="toc-text">#</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">java 中的函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ts-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.</span> <span class="toc-text">ts 中的函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.3.</span> <span class="toc-text">注意函数定义的顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">DOM 相关的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-Element-%E7%AD%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">Node Element 等类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">事件参数类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":245,"height":415},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7},"log":false});</script></body></html>
